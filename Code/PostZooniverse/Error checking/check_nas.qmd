---
title: "Check NAs"
format: html
editor: visual
---

### Overview

Investigating the reason that the files:

NoCoW_class-15-Feb-2024-wfn21244_wfv13.3_lastones_new.csv

NoCoW_class-15-Feb-2024-wfn16695_wfv11.8_lastones_new.csv

have so many NAs.

### Set up and read in a file

```{r}
rm(list = ls())
library(tidyverse)
library(here)

file1 <- read.csv(here("Output/PostZooniverse/Consensus/By workflow/wfn21244_wfv13.3/NoCoW_class-15-Feb-2024-wfn21244_wfv13.3_lastones_new.csv"),stringsAsFactors = T)
file1_name <- "NoCoW_class-15-Feb-2024-wfn21244_wfv13.3_lastones_new.csv"

file2 <- read.csv(here("Output/PostZooniverse/Consensus/By workflow/wfn16695_wfv11.8/NoCoW_class-15-Feb-2024-wfn16695_wfv11.8_lastones_new.csv"),stringsAsFactors = T)

file2_name <- "NoCoW_class-15-Feb-2024-wfn16695_wfv11.8_lastones_new.csv"
```

Now find the subject ids and file names for each subject that has NAs for the images

First find the subject ids we need to investigate

```{r}
first_set <- which(is.na(file1$Img1))

second_set <- which(is.na(file2$Img1))
df_length <- length(first_set)+length(second_set)
```
Next create a data frame to receive the results

```{r}
Subjects <- data.frame(subject_ids = integer(df_length),
                       issue_filename = character(df_length))
```

Now populate the DF with results
```{r}
#first go to file1
Subjects$subject_ids[1]<- file1$subject_ids[first_set]
Subjects$issue_filename[1] <- file1_name

Subjects$subject_ids[2:67] <- file2$subject_ids[second_set]
Subjects$issue_filename[2:67] <- file2_name
```
Now write file

```{r}
write.csv(Subjects, here("Data/PostZooniverse/consensus_w_NA_files.csv"), row.names = F)
```

Now let's look at how the files were created that resulted in subject ids with image names of NA.
The files are generated by the code in the file 

`./Code/PostZooniverse/3_Consensus_picks/3.determine_consensus_picks.Rmd`

So I'm going to copy that code below:

### Code that generated the files with NAs
Copying code from `./Code/PostZooniverse/3_Consensus_picks/3.determine_consensus_picks.Rmd`

Set up the path to the flattened classification file; normally this works with rstudioapi, but here we will just give the path to the files with issues:

NoCoW_class-15-Feb-2024-wfn21244_wfv13.3_lastones_new.csv

NoCoW_class-15-Feb-2024-wfn16695_wfv11.8_lastones_new.csv


```{r}
file1_original <- here("Output/PostZooniverse/Flattened/Species_ID/Check/need to process/NoCoW_class-15-Feb-2024-wfn21244_wfv13.3_flat_2024-04-02.csv")

file2_original <- here("Output/PostZooniverse/Flattened/Species_ID/Check/need to process/NoCoW_class-15-Feb-2024-wfn16695_wfv11.8_flat_2024-04-02.csv")
```

Start with first file
```{r}
Flat <- read.csv(file1_original, stringsAsFactors = T) #obviously, put correct file name here
```

Now filter for proper subject id

```{r}
Flat <- Flat %>% filter(subject_ids %in% Subjects$subject_ids)
```
Ah ha! I see why there was no Img1, Img2, Img3 - because this is from one of the JSON formats where the files were named Img4, Img5, Img6.  

Let's pull in the other file

```{r}
Flat2 <- read.csv(file2_original, stringsAsFactors = T) 

Flat2 <- Flat2 %>% filter(subject_ids %in% Subjects$subject_ids)
```
Now compare names of the two data frames

```{r}
names(Flat)
names(Flat2)

#Are the names the same?
names(Flat) == names(Flat2)
```
Columns 12 -16 are different. Let's fix that.

```{r}
names(Flat[12:16])
names(Flat2[12:16])
```
The columns need to be rearranges
```{r}
Flat2 <- Flat2 %>% relocate(answers.HOWMANYPEOPLE:answers.WHATTYPEOFHUMAN, .before = answers.HOWMANY)

names(Flat[12:16])
names(Flat2[12:16])

#see if that fixed it
names(Flat) == names(Flat2)
```
Ok - column names are the same, so I should be able to bind them into one data frame.

```{r}
Flat3 <- rbind(Flat, Flat2)
rm(Flat, Flat2)
Flat <- Flat3
rm(Flat3)
```
Ok - now move ahead.


Check to see if data are from multiple rounds. If beta test round is present, get rid of it

```{r}
unique(Flat$round)
```

```{r}
#get rid of data from beta test
#Flat<-Flat %>% filter(round !="beta test")
```

Parse the flat file into several data frames for simplicity; they will be joined back together later.

1.  Get rid of junk columns added by writing csv files (e.g. "X", "X.1")

```{r}
#use select and ! (not) to exclude columns that start with X
Flat <- Flat %>% select(!starts_with("X"))
```

Now for ease of viewing, get rid of all columns that are empty. First determine which they are

```{r}

empty_cols<-sapply(Flat, function(x)all(is.na(x))) #identify the columns that only contain NA

#use dplyr to get rid of them. Note that if the count of NAs is equal to the number of rows, the column must be all NAs

Flat <- Flat %>%  select(
  where(
    ~sum(!is.na(.x)) > 0
  )
)
#now add back Event column
Flat$Event <- NA

```

2.Summarize the data to see the number of distinct subjects (events) and the number of distinct classifications in the data set.

```{r}
Flat %>% summarise(n_distinct(subject_ids), n_distinct(classification_id)) 
```

Create a new column that has a count of how many unique classifications were made.

```{r}
Flat<-Flat %>% 
     group_by(subject_ids) %>% # count up the number of distinct classification IDs
     mutate( 
            num_class = n_distinct(classification_id),
            num_diff_species = n_distinct(choice)) %>% #because there will be >1 row per classification_id if >1 spp
     arrange(subject_ids, classification_id) 
Flat %>% View
```

Now arrange in descending order of the number of species identified.

```{r}
Flat %>% arrange(desc(num_diff_species)) %>% View()
```

Now that we know the number of species identified per subject id, we need a way to determine the consensus species for each subject id. First we'll write some code to check the species counts per subject id and classification id.

## Subject-level metrics

Generate some information about each subject_id

```{r}
subject_metrics <- Flat %>% ungroup %>%
     group_by(subject_ids) %>%
     mutate(num_votes = n(), # if a  user ids >1 spp in a classification (e.g. dog and human), there will be more votes than classifications
            ) 
```

Now look at species-level metrics

```{r}
species_counts <- Flat %>% ungroup %>%
     group_by(subject_ids, classification_id) %>%
     summarise(total_spp_by_user = mean(num_diff_species)) %>% #Need to select only one row per classification_id, then summarise across those. 
     summarise(., agg_num_species = round(median(total_spp_by_user), 0))#aggregate species count, which is median rounded up
     glimpse(species_counts)
     
#species counts gives a list by subject_id of the number of species identified by the different classifiers.
```

Now get the cleaned classifications

```{r}
cleaned_classifications <- left_join(subject_metrics, species_counts) %>% ungroup
glimpse(cleaned_classifications)
```

## Species level metrics

```{r}
grouped_classifications <- cleaned_classifications %>% 
      group_by(subject_ids, num_class, num_votes, agg_num_species, num_diff_species, choice) # fields at subject level or higher
```

#Tally the votes for each species ID'd within a subject. This yields species_votes, which tells us, for each subject_id, the number of classifications and the proportion of the vote received by each species for each subject_id. We can use this to run a list of subjects for which we need to go back and confirm the species.

```{r}
species_votes <- grouped_classifications %>% 
     # for every species within a subject, aggregate votes.
     summarise(., votes = n_distinct(classification_id),
               Event = max(Event)) %>% #count up the number of votes per species choice
     mutate(propvote = votes/sum(votes), #calculate proportion of votes for this species
            propclass = votes/num_class) 
```

Now obtain the correct classifications. These are the cases for which the number of classifications = number of votes AND for which the num_diff_species = 1. In other words, for all votes cast, there was agreement on what the subject contained.

```{r}
correct_classifications <- cleaned_classifications %>% filter(num_class == num_votes & num_diff_species == 1)
#now get list of correct subject ids

correct_subjects <- unique(correct_classifications$subject_ids)
```
It makes sense that there are no correct classifications, because I'm dealing with data from two files for which we needed to check the classifications. 


When num_votes > num_class you have a situation where there was more than one species detected in an event (typically Gus and one or more camera trappers.). In these cases, propvote will not equal propclass, and the sum of propclass for that subject id will be greater than 1.0 (though the sum of propvote will be equal to 1.)

```{r}
MoreThan1<-species_votes %>% filter(num_votes > num_class)
```

They each show the same subject_ids so things look good.

We know there is a discrepancy about what the species is for these files. We just need a better file with correct image numbers to check agains.


```{r}

filesToCheck<-cleaned_classifications
```



And now summarize

```{r}
#these may need adjusting based on what columns are present in the particular file
filesToCheckSummary<-filesToCheck %>% group_by(subject_ids) %>% reframe(
  workflow_name = as.character(workflow_name),
  workflow_version = workflow_version,
  choice = as.character(choice),
  Img1 = as.character(Img4),
  Img2 = as.character(Img5),
  Img3 = as.character(Img6),
  #Forest = Forest,
  num_class = num_class,
  num_diff_species = num_diff_species
)

```

Now loop through filesToCheck to grab just the first instance of each subject id and associated variables.

Make data frame to put results in

```{r}
NewSubjects<-unique(filesToCheckSummary$subject_ids)

Checklist<-data.frame(subject_ids = integer(length(NewSubjects)),
                      # workflow_name = character(length(NewSubjects)),
                      # workflow_version = numeric(length(NewSubjects)),
                      Img1 = character(length(NewSubjects)), 
                      Img2 = character(length(NewSubjects)), 
                      Img3 = character(length(NewSubjects)),
                      num_class = integer(length(NewSubjects)),
                      num_diff_species = integer(length(NewSubjects)))
```

Now loop

```{r}
for(i in 1:length(NewSubjects)){
  mySample<-filter(filesToCheckSummary, subject_ids == NewSubjects[i])
  Checklist$subject_ids[i]<-NewSubjects[i]
  # Checklist$workflow_name[i] <-unique(mySample$workflow_name)
  # Checklist$workflow_version <-unique(mySample$workflow_version)
  Checklist$Img1[i]<-unique(mySample$Img1)
  Checklist$Img2[i]<-unique(mySample$Img2)
  Checklist$Img3[i]<-unique(mySample$Img3)
  Checklist$num_class[i]<-unique(mySample$num_class)
  Checklist$num_diff_species[i]<-unique(mySample$num_diff_species)

}
```

Add column for final species ID

```{r}
Checklist$Final_choice <- NA
Checklist$File_location <- NA
Checklist$Classifier <- NA
Checklist$Notes <- NA
```

Now save

```{r}

write.csv(Checklist, here("Output/PostZooniverse/Consensus/By workflow/wfv11.8_wfv13.3_have_nas.csv"),row.names = FALSE)
#row.names=FALSE prevents R from adding X column in output df

```

N